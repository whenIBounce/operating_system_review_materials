# Chapter 9 Main Memory

> **Every address generated by a user program is a virtual address. **

> The OS is just providing an *illusion*
to each *process*, specifically that it has its own large and private memory;

> with some *hardware* help, the OS will turn these pretend virtual addresses into real
physical addresses, and thus be able to locate the desired information

## Intuition: Why does the OS want to provide this illusion(virtual memory)?
Mostly **ease of use**: the OS will give each program the view that it
has a *large contiguous **address space*** to put its code and data into; thus, as a
programmer, you never have to worry about things like “where should I store this
variable?” 

**Isolation** and **protection** are big deals, too. We don’t want
one errant program to be able to read, or worse, overwrite, some other program’s
memory.

## Address Space
1. What is address space?
   - It was invented to create an easy to use abstraction of physical memory.
   - It is the **running program's view of memory** in the system. 
   - The address space of a process contains **all** of the memory state of the running program (the code of the program, a stack, a heap). 
1. What is the job of the OS in this set of notes?
    To virtualize memory. <br>

    The OS, with some serious hardware help, will take each of these virtual memory references, and turn them into physical addresses, which can be presented to the physical memory in order to
    fetch the desired information. 

    The OS will do this for many processes at once, making sure to protect programs from one another, as well as protect the OS. 

> Ever write a C program that prints out a pointer? The value you see
(some large number, often printed in hexadecimal), is a virtual address.

3. Goals of a virtual memory (VM) system?
    - Transparency: The OS should implement virtual memory in a way that is *invisible* to
the running program. Thus, the program shouldn’t be aware of the fact
that memory is virtualized;
    - Efficiency: both time and space, (i.e., not using too much
memory for structures needed to support virtualization). 
    - Protection -> isolation

## Memory API
1. The `malloc()` call and the `free()` call
    ```
    int *x = malloc(10 * sizeof(int));
    printf("%d\n", sizeof(x));
    ```
    What is the output? Why? (hint: *compile-time* operator)

    ```
    int x[10];
    printf("%d\n", sizeof(x));
    ```
    What is the output? Why?
2. Give an example for each of the following common errors:
   - Segmentation fault
   - Buffer overflow
   - Memory leak
   - Dangling pointer
   - Double free
3. Compile and Run `./code/memory_api.c`
4. Other Calls: `calloc()`, `realloc()`.